+++
title = "Первый скрипт на Python"
date = "2016-01-20T13:10:07+03:00"
tags = ["python"]
categories = ["Development"]
draft = true
description = "Первый скрипт на Python. С нуля и до рабочей версии. Запуск в командной строке"
keywords = "python, python 3, скрипт, todoist, первый скрипт, pip3, установка python, установка питона, питон, ConfigParser, ArgumentParser"
aliases = [
    "/posts/my-first-python-script/",
    "/2016/01/python.html"
]
+++

Мысль изучить питон была уже давно. Мне постоянно рассказывали, какой он легкий, как на нем хорошо писать прототипы (да и не только), какая у него высокая скорость разработки (особенно если не писать тесты :)) и как он совмещает в себе и объектно-ориентированный, и функциональный подход. Послушаешь, не язык, а чудо просто. И вот, настало время для моего первого скрипта. Первое что пришло в голову, это оптимизировать перенос просроченных задач на сегодня в системе todoist. Чтобы сделать это в приложении надо выделять необходимые задачи с нажатой клавишей shift, пройти сквозь меню и нажать заветную кнопку перенести на сегодня. Но, всегда возникали некоторые трудности. То нажатие некорректно обработается, то вместо выделения начинается перенос. Не сказать что самый приятны процесс. Время для автоматизации!

### Установка Python 3

По умолчанию в Mac OS X, El Capitan, установлена версия 2.7. И то не самая последняя. Поэтому рассмотрим один из простых и удобных способов установить Python 3.

Нам понадобится менеджер пакетов [Homebrew](http://brew.sh/). У кого он не установлен, советую это сделать. Для этого открываем терминал и вводим следующую команду:

``` shell
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

Все, теперь просто вводим:

``` shell
brew install python3
```

После установки проверим работоспособность запустив интерактивную консоль командой `python3`.

### Использование pip, как получить нужную библиотеку

Следующий этап – установка библиотеки для работы с API Todoist. Для этого тоже воспользуемся менеджером пакетов pip3, который поставляется вместе с Python 3. Для установки пакета todoist-python просто введем:

``` shell
pip3 install todoist-python
```

Хочу напомнить о замечательной командной оболочке Zsh, о которой я [писал ранее](http://www.agladky.ru/2015/11/zsh-bash.html). С помощью плагинов `brew` и `pip` можно легко работать с пакетами, используя автодополнение.

### Среда разработки

Тут все просто. Как давний пользователь Resharper, я обратился к другому продукту компании JetBrains – [PyCharm](https://www.jetbrains.com/pycharm/). Автодополнение, рефакторинг, дебаг, вот это вот все. IDE очень помогает со всем этим, особенно новичку. Тем более, есть бесплатная версия – Community Edition, которой более чем достаточно.

### CodeStyle и конвекция имен

На этот счет есть планы написать отдельную статью-шпаргалку. А пока, немного о стиле именования.

Имена функций, методов и переменных экземпляров классов должны состоять из маленьких букв, а слова разделяться символами подчеркивания. Стиль mixedCase допускается в тех местах, где уже преобладает такой стиль, для сохранения обратной совместимости. Для непубличных методов и атрибутов используется один символ подчёркивания перед именем.

### Итерация и получение значений из коллекций

Перейдем непосредственно к коду.

Библиотека todoist в качестве ответа на запрос о просроченных задачах возвращает значения в виде словаря или списка. Возник вопрос – как работать с коллекциями?

Итерация оказалось простая. Почти то же самое что и в C#, только там используется ключевое слово `foreach`.

``` python
for overdue_item in overdue_items:
      item = api.items.get_by_id(overdue_item['id'])
      print item
```

Получить значение в словаре можно 2 способами. Первый, это непосредственное обращение по ключу через следующую конструкцию:

``` python
id = overdue_item['id']
```

Но в случае, если такой пары значений в коллекции не будет, то произойдет ошибка – `KeyError: 'id'`. Поэтому, когда присутствует неуверенность в наличии ключа, следует использовать следующий метод:

``` python
id = overdue_item.get('id')
```

Он тоже возвращает значение по ключу, но если его нет не бросает исключение, а возвращает значение по-умолчанию (`None`).

### Преобразование и работа с датой

Следующие возникшие вопросы – как работать с датой? Как ее парсить, находить дельту, добавлять значения и приводить к определенному строковому формату.

Разберем следующий код из моего скрипта:

``` python
item_due_date = datetime.strptime(item['due_date_utc'], '%a %d %b %Y %H:%M:%S %z')
delta = datetime.utcnow().date() - item_due_date.date()
item_today_date = item_due_date + timedelta(days=delta.days)
item.update(due_date_utc=item_today_date.strftime('%Y-%m-%dT%H:%M:%S'))
```

1. По ключу `due_date_utc` получаем дату в формате `"Fri 26 Sep 2014 08:25:05 +0000"`. Переводим в формат понятный python с помощью метода `datetime.strptime()` и выражения `'%a %d %b %Y %H:%M:%S %z'`, о принципах составления которого можно узнать в [документации Python](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
2. Находим разницу между текущей датой и датой полученного объекта.
3. Актуализируем дату объекта, добавляя к нему полученную в предыдущем пункте разницу дней, с помощью `timedelta(days=delta.days)`.
4. Отправляем изменения в Todoist, переведя дату в строку с помощью `item_today_date.strftime('%Y-%m-%dT%H:%M:%S')`

### if __name__ == "__main__":

Очень часто, читая чей-то код на github, встречал подобную конструкцию. Давайте выясним, что это.

Когда скрипт запускается как команда,

```
python TodoistOverdue.py
```

выполняется весь код на уровне 0. Например, определяются функции и классы (но не выполняются).

`__name__` это встроенная переменная, которая хранит имя текущего модуля. Однако, если модуль запускается непосредственно (как TodoistOverdue.py выше), тогда переменной `__name__` устанавливается значение `"__main__"`. Т.е., если импортировать модуль из другого модуля, например так:

``` python
import TodoistOverdue
```

код, приведенный в условии

``` python
if __name__ == "__main__":
    ...
```

попросту не выполнится. Но, если модуль вызвать как отдельный скрипт, то код из условия выполнится.

### Добавление атрибутов командной строки

Мой скрипт может принимать на вход значения токена api todoist. Для этого необходимо вызвать скрипт следующим образом:

``` shell
python TodoistOverdue.py -t 0123456789abcdef0123456789abcdef01234567
```

Рассмотрим, как задавать описание скрипта и определять аргументы:

``` python
parser = argparse.ArgumentParser(description="Moving overdue tasks for today in todoist")
parser.add_argument("-t", "--token", help="Todoist API token")
args = parser.parse_args()
```

1. Инициализируем класс `ArgumentParser`, который помогает работать с командной строкой, и задаем описание скрипта.
2. Добавляем аргумент, который можно задавать с помощью ключа `'-t'` или `'--token'`. Параметр `help` определяет описание, показываемое при вызове скрипта с ключом `-h`.
3. Переводим строки аргументов в объекты и присваиваем их как атрибуты к указанной переменной (`args`).

Теперь, если запустить скрипт как указано выше, то при вызове `args.token` получим значение – `0123456789abcdef0123456789abcdef01234567`. Про остальные параметры и методы можно узнать в [документации python](https://docs.python.org/3.5/library/argparse.html).

### Чтение и запись в файл конфигурации

Полученный token api хранится в конфигурационном файле. Следующий код описывает доступ, чтение и запись значения:

``` python
config = configparser.ConfigParser()
config.read(expanduser('~') + "/.todoist")
token = args.token
if token is None:
    token = config['Global']['TokenAPI']
else:
    config['Global'] = {'TokenAPI': token}
    with open(expanduser('~') + "/.todoist", 'w') as configfile:
        config.write(configfile)
```

1. Инициализируем `ConfigParser` и читаем файл из домашней директории пользователя. `expanduser('~')` позволяет получить путь к директории как в Windows, так и в \*nix системах.
2. `config['Global']['TokenAPI']` читаем конфиг так же как и словарь. Сначала указываем, в какой секции находится значение, а потом и ключ для самого значения.
3. В блоке `else` происходит запись значения токена, если при старте скрипта было указано значение. После конфигурационный файл записывается на диск.

Мне очень понравилось, как лаконично и быстро можно записать изменения в файл. В отличии от C#, где надо открывать потоки, указывать много дополнительной информации, здесь это просто 2 строчки. Возьми это и запиши сюда, все. Для дополнительной информации о ConfigParser можно обратиться на соответствующую [страницу в документации](https://docs.python.org/3/library/configparser.html). Информацию о вводе и выводе в Python 3 можно подчерпнуть [здесь](https://docs.python.org/3.5/tutorial/inputoutput.html).

### Заключение

Вот и все. Первое знакомство с языком Python оставило хороше впечатление. Как минимум, его стоит изучить на базовом уровне, чтобы автоматизировать множество мелких процессов происходящих вокруг вас. Так же, он идеально подойдет для написания прототипа идеи, засевшей у вас в голове.

Полный скрипт `TodoistOverdue.py` из этой статьи можно посмотреть в [gist](https://gist.github.com/agladky/f7853721841bc4486712).

### Полезные ссылки

- Как запускать скрипты в Mac Os X без указании полного пути. [Stackoverflow](http://stackoverflow.com/questions/4718071/how-can-i-run-my-python-script-from-the-terminal-in-mac-os-x-without-having-to-t).
- Изучить питон за пару минут (learnxinyminutes.com). [Русская](https://learnxinyminutes.com/docs/ru-ru/python3-ru/) и [английская](https://learnxinyminutes.com/docs/python3/) версия.
- Документация для [Python 3.5.1](https://docs.python.org/3.5/index.html).
