+++
title = "Как тестировать абстрактные классы"
date = "2015-09-05T13:10:07+03:00"
tags = ["test"]
categories = ["Development"]
draft = true
description = "Как производить рефакторинг и unit-тестирование абстрактных классов."
keywords = "рефакторинг, unit, unit-test, абстрактные классы, c#, .net, хелпер, helper"
aliases = [
    "/posts/how-to-test abstract-classes/",
    "/2015/09/blog-post.html"
]
+++

Что делать, когда вы встречаете абстрактные классы, которые сложно тестировать? Один из правильных ответов - избавляться от них. В данной статье я приведу 2 основных способа применения абстрактных классов и их рефакторинга для проведения Unit тестирования.

Для начала, опишем ситуации:

1. Существует специализированный абстрактный класс, но все клиенты используют его конкретные реализации через единый публичный интерфейс.
2. Абстрактный класс помогает избежать повторений в наследуемых классах. Клиенты используют конкретные реализации классов напрямую.

#### Решение для первой ситуации - Шаблон Стратегия.

![](https://lh3.googleusercontent.com/-Q17gK6ru1Ao/Vh6PH2fppfI/AAAAAAAAAiM/zeQXaGI1myw/s640-Ic42/Situation1_before_my.png "Cитуация 1 до")

В действительности в первой ситуации мы имеем дело с интерфейсом, методы которого определены виртуальными методами абстрактного класса.

Чтобы повысить тестируемость класса, необходимо выделить этот интерфейс и сделать его реальным. Абстрактный класс следует превратить в конкретный и в его конструкторе ввести параметр для получения экземпляра этого интерфейса. Классы-потомки, соответственно, теперь должны реализовывать выделенный интерфейс.

Т.е. в данной ситуации будет реализован шаблон проектирования [стратегия](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\)).

![](https://lh3.googleusercontent.com/-jgWvDdeAlao/Vh6PH2OF0CI/AAAAAAAAAiA/5EoJ4lRRonE/s640-Ic42/Situation1_after_my.png "Cитуация 1 после")

Это означает, что теперь можно тестировать бывший абстрактный класс используя мок-объект нового интерфейса. Все просто и легко тестировать.

#### Решение для второй ситуации

Во второй ситуации абстрактный класс работает как хелпер (helper).

![](https://lh3.googleusercontent.com/-HxhHgIWdCds/Vh6PINmZ0NI/AAAAAAAAAiI/20-toWjmQHE/s640-Ic42/Situation2_before_my.png "Cитуация 2 до")

Рассмотрим содержащуюся в нем функциональность. Если можно перенести что-нибудь в существующие объекты для уменьшения дублирования, то делаем это. Если в классе все еще присутствуют методы, то их стоит выделить в хелпер, и передавать его интерфейс в конструкторы конкретных классов.

![](https://lh3.googleusercontent.com/-9oAhCjCnrFc/Vh6PH7B1ffI/AAAAAAAAAiE/q06QyuW6SAc/s640-Ic42/Situation2_after_my.png "Cитуация 2 после")

Теперь можно удалить базовый класс. Это снова приведет дизайн к конкретным классам, который просто и легко тестировать.

#### Возьмите за правило

Предпочитайте сложную сеть простых объектов над простой сетью сложных. Ключ к трестируемому коду это маленькие строительные блоки и слабая связанность.

#### Как справится с комбинацией обоих случаев?

Возможно, вы встретите ситуацию, когда базовый класс содержит в себе обе ситуации. Т.е. у него есть публичный интерфейс и защищенные (protected) методы-помощники (helpers). В этом случае, можно отправить все вспомогательные методы в один класс (сценарий 2) и реализовать для наследников шаблон стратегия (сценарий 1).

Для ситуации когда некоторые методы абстрактного класса реализуются в нем, а другие являются виртуальными, все еще возможно провести рефакторинг. Например, превратить наследников в стратегию. Но подобный класс является хорошим индикатором, что существующие ответственности надо пересмотреть и провести рефакторинг.

Бывают случаи, когда абстрактный класс необходим или без него сложно обойтись. Мне было бы интересно прочитать подобные примеры в комментариях.
