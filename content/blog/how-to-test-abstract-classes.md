+++
title = "Как тестировать абстрактные классы"
date = "2015-09-05T13:10:07+03:00"
tags = ["test"]
categories = ["Development"]
draft = false
description = "Как производить рефакторинг и unit-тестирование абстрактных классов."
keywords = "рефакторинг, unit, unit-test, абстрактные классы, c#, .net, хелпер, helper"
slug = "how-to-test-abstract-classes"
aliases = [
    "/posts/how-to-test abstract-classes/",
    "/posts/how-to-test-abstract-classes/",
    "/2015/09/blog-post.html"
]
+++

Абстрактные классы сложно тестировать. Рассмотрим ситуации применения абстрактных классов и последующего рефакторинга для проведения юнит тестирования.

### Выделить реальный интерфейс
Существует специализированный абстрактный класс, но все клиенты используют его конкретные реализации через единый публичный интерфейс:

![](https://lh3.googleusercontent.com/-Q17gK6ru1Ao/Vh6PH2fppfI/AAAAAAAAAiM/zeQXaGI1myw/s640-Ic42/Situation1_before_my.png "Cитуация 1 до")

Классы-потомки реализуют интерфейс, определенный абстрактными методами класса. Для повышения тестируемости этот интерфейс выделяется. Абстрактный класс превращается в конкретный и в его конструктор передается объект классов-потомков, реализующих выделенный интерфейс.

Применяется шаблон проектирования [стратегия](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_\(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\)).

![](https://lh3.googleusercontent.com/-jgWvDdeAlao/Vh6PH2OF0CI/AAAAAAAAAiA/5EoJ4lRRonE/s640-Ic42/Situation1_after_my.png "Cитуация 1 после")

Бывший абстрактный класс теперь тестируется используя мок-объект нового интерфейса. Все просто.

### Выделить хелпер
Абстрактный класс используется для исключения повторений в наследуемых классах. Классы-потомки используются напрямую.

![](https://lh3.googleusercontent.com/-HxhHgIWdCds/Vh6PINmZ0NI/AAAAAAAAAiI/20-toWjmQHE/s640-Ic42/Situation2_before_my.png "Cитуация 2 до")

Абстрактный класс работает как хелпер (helper).

Чтобы повысить тестируемость, не повторяющийся код переносится в существующие классы. Оставшиеся методы выделяются в хелпер и передаются через интерфейс в конструкторы конкретных классов.

![](https://lh3.googleusercontent.com/-9oAhCjCnrFc/Vh6PH7B1ffI/AAAAAAAAAiE/q06QyuW6SAc/s640-Ic42/Situation2_after_my.png "Cитуация 2 после")

Базовый класс удаляется. Этот способ снова приводит дизайн к конкретным классам, которые просто и легко тестировать.

### Совет
Предпочитайте сложную сеть простых объектов над простой сетью сложных. Ключ к трестируемому коду — маленькие строительные блоки и слабая связанность.

### Комбинация ситуаций
Встречаются ситуации когда базовый класс содержит как публичный интерфейс, так и защищенные методы-помощники. В этом случае вспомогательные методы отправляются в один класс (ситуация 2), а для наследников реализуется шаблон стратегия (ситуация 1).

Когда в абстрактном классе часть методов виртуальные, а часть реализованные, еще возможно провести рефакторинг. Например, превратить классы наследники в стратегию. Но, такой случай — хороший индикатор, что ответственности требуют пересмотра.

Пишите в комментариях примеры когда сложно обойтись без абстрактного класса.
