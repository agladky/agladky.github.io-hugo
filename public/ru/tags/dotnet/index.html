<!DOCTYPE html>
<html lang="ru-RU">
  <head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="Блог Анатолия Гладкого">
    <meta name="author" content="Анатолий Гладкий">
    <meta property="og:title" content="Dotnet" />
<meta property="og:description" content="Блог Анатолия Гладкого" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://agladky.ru/tags/dotnet/" />
<meta property="og:updated_time" content="2016-12-13T17:10:07&#43;03:00"/><meta property="og:site_name" content="Анатолий Гладкий" />

    
  
    <base href="https://agladky.ru/">
    <title>Dotnet</title>
    <link rel="canonical" href="https://agladky.ru/tags/dotnet/">
    <link rel="shortcut icon" href="https://agladky.ru/img/favicon.ico">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,400i,700,700i"><link rel="stylesheet" href="https://agladky.ru/css/reset.css?t=1552135052">
    <link rel="stylesheet" href="https://agladky.ru/css/pygments.css?t=1552135052">
    <link rel="stylesheet" href="https://agladky.ru/css/likely.css?t=1552135052">
    <link rel="stylesheet" href="https://agladky.ru/css/main.css?t=1552135052">
    
    <script async src="https://agladky.ru/js/likely.js"></script>
  </head>

  <body>
    <div class="page-container">
      <header class="page-header section-skin">

        <div class="page-header__up">
          <a class="page-header__avatar-link" href="https://agladky.ru/">
            <img class="page-header__avatar" src="https://agladky.ru/img/avatar.jpg">
          </a>

          <span class="page-header__name"><a class="page-header__name-link" href="https://agladky.ru/"> Анатолий Гладкий</a></span>

          <div class="page-header__lang">
              
            </div>
        </div>
        
        <div class="page-header__bottom">
          <nav class="page-header__menu">
                <span class="page-header__menu-item page-header__menu-item--first">
                  <a href="https://agladky.ru/blog/" class="page-header__menu-link">Блог</a>
                </span>
          </nav>
        </div>
      </header>

      <main class="main-layout__container section-skin">
        <div class="main-layout__content">
            
  <header class="section-head__wrapper">
    <div class="section-head__subhead-top">Заметки с тегом</div>
    <div class="section-head">Dotnet</div>
  </header>

  
  <article class="article-layout">
    <header class="article-head__wrapper">
      <div class="article-head">
        <a class="article-head__link" href="https://agladky.ru/blog/async-await-example/">Сравнение async await и Task.ContinueWith()</a>
      </div>
    </header>

    <div class="article-content markdown--blackfriday">
      

<p>Это краткая выжимка из рабочего доклада по работе с async/await в C#. Для наглядности, параллельно рассматривается подход с использованием блока <code>ContinueWith</code>.</p>

<h3 id="орррсновные-паттерны-асинхронного-программирования">ОРррсновные паттерны асинхронного программирования</h3>

<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/ms228963.aspx">Asynchronous Programming Model (APM)</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/ms228969.aspx">Event Asynchronous Pattern (EAP)</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/hh873175.aspx">Task Asynchronous Pattern (TAP)</a>

<ul>
<li>Задачи представляют параллельные операции</li>
<li>Могут выполняться на отдельном или разных потоках.</li>
<li>Могут быть скомбинированы и выстроены в цепочку вызовов.</li>
</ul></li>
</ul>

<h3 id="async-await-синтаксическая-обертка-над-задачами">async/await — синтаксическая обертка над задачами</h3>

<ul>
<li><code>await</code> ставит на паузу текущий метод, ожидая выполнения задачи.</li>
<li>Выглядит как блокирующая (синхронная) операция.</li>
<li>Не блокирует текущий поток.</li>
<li>Выполнение продолжается в том же контексте, из которого была вызвана задача, если явно не указано иное.</li>
<li>Ключевое слово <code>async</code> указывается, чтобы среда исполнения воспринимала <code>await</code> как ключевое слово.</li>
<li><code>await</code> метод начинает выполняться синхронно. Если он уже закончил свое выполнение то новый поток не создается. Все продолжается в том же потоке. Подробнее в <a href="http://stackoverflow.com/questions/17380070/c-sharp-async-awaitable-clarification">ответе на stackoverflow.com</a>.</li>
<li><code>await</code> работает с любым типом, для которого реализован метод <code>GetAwaiter()</code>. Подробнее в статье - <a href="http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115642.aspx">await anything</a>.</li>
</ul>

<h3 id="демонстрационное-приложение">Демонстрационное приложение</h3>

<p>Примеры показываются на тестовом Windows Form приложении. <a href="https://github.com/agladky/async_await_article">GitHub репозиторий с приложением</a>.</p>




    


<figure>
	<img src="https://agladky.ru/blog/async-await-example/images/async-await-test-window.png" alt="async/await тестовое окно">
	<figcaption style="font-size: 0.8rem"></figcaption>
</figure>


<p>Асинхронные действия лежат в <code>PeopleRepositoryAsync</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">PeopleRepositoryAsync</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="n">GetPeopleList</span><span class="p">()</span>
    <span class="p">{</span>        
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">2000</span><span class="p">);</span>                       
        <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="s">&#34;John Smith&#34;</span><span class="p">,</span>  
            <span class="s">&#34;Ivan Ivanov&#34;</span><span class="p">,</span>
            <span class="s">&#34;Joao Fetucini&#34;</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Метод <code>GetPeopleList()</code> асинхронно ожидает 2 секунды и возвращает список пользователей.</p>

<h3 id="первое-сравнение-tap-и-async-await-подхода">Первое сравнение TAP и async/await подхода</h3>

<h4 id="реализация-с-task-и-continuewith">Реализация с Task и ContinueWith</h4>

<p>Добавим код для получения списка пользователей в обработчик нажатия кнопки &ldquo;Fetch Data (with Task)&rdquo; - <code>buttonTask_Click</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">Task</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="n">peopleTask</span> <span class="p">=</span> <span class="n">Repository</span><span class="p">.</span><span class="n">GetPeopleList</span><span class="p">();</span>
<span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">people</span> <span class="p">=</span> <span class="n">peopleTask</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span></code></pre></div>
<p>Этот код не будет выполняться асинхронно. Он будет ожидать завершение задачи <code>peopleTask</code> в основном потоке, поэтому UI заморозится. Добавим конструкцию <code>ContinueWith(t =&gt; { })</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">peopleTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span>
<span class="p">{</span>
  <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">people</span> <span class="p">=</span> <span class="n">peopleTask</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
<span class="p">});</span></code></pre></div>
<p>Теперь задача по получению пользователей выполнится асинхронно. После её завершения выполнится код в блоке <code>ContinueWith</code>.
Добавим в <code>ContinueWith</code> отображение полученных имен в <code>textBoxMain</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">textBoxMain</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="s">$&#34;{Environment.NewLine}Person list:{Environment.NewLine}&#34;</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">person</span> <span class="k">in</span> <span class="n">people</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">textBoxMain</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="s">$&#34;- {person}{Environment.NewLine}&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Если запустить приложение и нажать на &ldquo;Fetch Data (with Task)&rdquo;, то возникнет ошибка. Все потому, что код в блоке <code>ContinueWith</code> выполняется в потоке, отличном от того где находится <a href="https://habrahabr.ru/post/232169/">SynchronizationContext</a> UI потока.
Для выполнения в нужном потоке добавим в вызов метода <code>ContinueWith</code> аргумент <code>TaskScheduler.FromCurrentSynchronizationContext()</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">peopleTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">FromCurrentSynchronizationContext</span><span class="p">());</span></code></pre></div>
<p>Теперь приложение работает корректно. Перейдем к реализации этого кода с помощью ключевых слов <code>async</code> и <code>await</code>.</p>

<h4 id="реализация-с-async-await">Реализация с async/await</h4>

<p>Основное отличие от предыдущей реализации — код будет похож на синхронный. Перейдем в обработчик нажатия кнопки &ldquo;Fetch Data (with await)&rdquo; - <code>buttonAwait_Click</code>. Добавим код для получения списка пользователей:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">people</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Repository</span><span class="p">.</span><span class="n">GetPeopleList</span><span class="p">();</span></code></pre></div>
<p>В объявление метода добавим слово <code>async</code>, чтобы среда исполнения поняла что <code>await</code> это ключевое слово, а не просто переменная. Вставим без изменений код из <code>ContinueWith</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">textBoxMain</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="s">$&#34;{Environment.NewLine}Person list:{Environment.NewLine}&#34;</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">person</span> <span class="k">in</span> <span class="n">people</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">textBoxMain</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="s">$&#34;- {person}{Environment.NewLine}&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Все. Приложение работает так же как и в предыдущем пункте. Код выглядит как синхронный. Выполнение продолжается в том же потоке, из которого и было вызвано.</p>

<h3 id="обработка-ошибок">Обработка ошибок</h3>

<p>Для демонстрации добавим в метод <code>GetPeopleList</code> код вызова ошибки (после <code>Task.Delay(2000)</code>):</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">(</span><span class="s">&#34;Метод не реализован!&#34;</span><span class="p">);</span></code></pre></div>
<h4 id="обработка-ошибок-для-await-метода">Обработка ошибок для await метода</h4>

<p>Сначала рассмотрим самый простой случай. Отлов и обработка ошибок для метода с <code>await</code> происходит как в синхронном коде:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">try</span>
<span class="p">{</span>
    <span class="c1">// Получение и вывод значений из репозитория
</span><span class="c1"></span><span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">,</span> <span class="s">&#34;ОШИБКА&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">finally</span>
<span class="p">{</span>
    <span class="c1">// Критичный к выполнению код
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<p>Всё. Дополнительно писать ничего не надо, ошибка будет поймана.</p>

<h4 id="обработка-ошибок-для-task-метода">Обработка ошибок для Task метода</h4>

<p>Для метода с блоком <code>ContinueWith</code> обработать ошибки можно несколькими способами.</p>

<p>Первый, использовать еще один вызов <code>ContinueWith</code> на задаче. Вызовем <code>ContinueWith</code> с 2 дополнительными параметрами:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">peopleTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="c1">// Получение и вывод значений из репозитория
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span>
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnRanToCompletion</span><span class="p">,</span>
    <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">FromCurrentSynchronizationContext</span><span class="p">());</span></code></pre></div>
<p>Главное — аргумент <code>TaskContinuationOptions.OnlyOnRanToCompletion</code>. Он указывает, что блок кода выполнится только если в задаче не было ошибок.</p>

<p>Теперь, код для обработки ошибки:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">peopleTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">exception</span> <span class="k">in</span> <span class="n">t</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">Flatten</span><span class="p">().</span><span class="n">InnerExceptions</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">exception</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span>
    <span class="n">TaskContinuationOptions</span><span class="p">.</span><span class="n">OnlyOnFaulted</span><span class="p">,</span>
    <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">FromCurrentSynchronizationContext</span><span class="p">());</span></code></pre></div>
<p>Опция <code>OnlyOnFaulted</code> указывает, что код в блоке выполниться только при ошибке в задаче. Оператор <code>foreach</code> разворачивает ошибки в «плоское» состояние, т. к. все ошибки представляются в виде иерархии и оборачиваются в <code>AggregateException</code>.</p>

<p>Для имитации блока <code>finally</code>, напишем:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">peopleTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="c1">// Критичный к выполнению код
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">);</span></code></pre></div>
<p>Второй способ обработки ошибок занимает меньше строк. В блок <code>ContinueWith</code> добавляется условный оператор, который проверяет статус задачи:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">peopleTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Status</span> <span class="p">==</span> <span class="n">TaskStatus</span><span class="p">.</span><span class="n">RanToCompletion</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Получение и вывод значений из репозитория
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Status</span> <span class="p">==</span> <span class="n">TaskStatus</span><span class="p">.</span><span class="n">Faulted</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Обработка ошибок
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// (finally) Критичный к выполнению код
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">FromCurrentSynchronizationContext</span><span class="p">());</span></code></pre></div>
<h3 id="отмена-действий">Отмена действий</h3>

<p>Обновим метод <code>GetPeopleList</code> класса <code>Repository</code>. Добавим параметр <code>CancellationToken</code> и точку отмены после вызова <code>Task.Delay(2000)</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="n">GetPeopleList</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationToken</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1500</span><span class="p">,</span> <span class="n">cancellationToken</span><span class="p">);</span>
    <span class="n">cancellationToken</span><span class="p">.</span><span class="n">ThrowIfCancellationRequested</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="p">}</span></code></pre></div>
<p>Обратит внимание, что отмена произойдет только после ожидания в 2 секунды. Само действие <code>Task.Delay</code> не прерывается.</p>

<p>Для операции отмены используем кнопку &ldquo;Cancel request&rdquo; с обработчиком <code>buttonCancel_Click</code>. Объекту <code>CancellationToken</code> можно задать значение только при инициализации. Поэтому создадим переменную <code>CancellationTokenSource</code>. Она позволяет генерировать токены и изменять их состояние во время выполнения.</p>

<p>В класс <code>MainForm</code> добавим поле:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="n">CancellationTokenSource</span> <span class="n">_tokenSource</span><span class="p">;</span></code></pre></div>
<p>А в обработчик <code>buttonCancel_Click</code>  код для подачи токену сигнала отмены:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">_tokenSource</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span></code></pre></div>
<h4 id="обработка-отмены-для-async-метода">Обработка отмены для async метода</h4>

<p>В обработчике <code>buttonAwait_Click</code> изменим вызов метода <code>GetPeopleList()</code>, добавив инициализацию <code>_tokenSource</code> и передав сгенерированный токен в качестве аргумента:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">_tokenSource</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
<span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">people</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Repository</span><span class="p">.</span><span class="n">GetPeopleList</span><span class="p">(</span><span class="n">_tokenSource</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span></code></pre></div>
<p>Добавим обработку операции отмены:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">,</span> <span class="s">&#34;Canceled&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h4 id="обработка-отмены-для-task-метода">Обработка отмены для Task метода</h4>

<p>Для <code>buttonTask_Click</code> добавим похожий код для передачи токена:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">_tokenSource</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>
<span class="n">Task</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="n">peopleTask</span> <span class="p">=</span> <span class="n">Repository</span><span class="p">.</span><span class="n">GetPeopleList</span><span class="p">(</span><span class="n">_tokenSource</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span></code></pre></div>
<p>Для обработки операции отмены в блок <code>ContinueWith</code> добавим:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Status</span> <span class="p">==</span> <span class="n">TaskStatus</span><span class="p">.</span><span class="n">Canceled</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Operation Canceled&#34;</span><span class="p">,</span> <span class="s">&#34;Canceled&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="deadlocks">Deadlocks</h3>

<p>Добавим в класс <code>Repository</code> метод <code>DeadlockTestAsync()</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="n">DeadlockTestAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1500</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Done!&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Вызовем этот метод в обработчике кнопки &ldquo;Deadlock&rdquo;:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">async</span> <span class="k">void</span> <span class="n">buttonDeadlock_Click</span>
<span class="p">{</span>
    <span class="n">Repository</span><span class="p">.</span><span class="n">DeadlockTestAsync</span><span class="p">().</span><span class="n">Wait</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p>Все. При нажатии на кнопку возникнет Deadlock. Почему? Рассмотрим по пунктам:</p>

<ol>
<li><code>DeadlockTestAsync()</code> вызывается на потоке с UI.</li>
<li><code>Task.Delay()</code> запускается в новом потоке.</li>
<li><code>await</code> захватывает <code>SynchronizationContext</code> и подключает continuation для выполнения действий после завершения.</li>
<li>Вернемся к вызову <code>DeadlockTestAsync()</code>.</li>
<li><code>Wait()</code> ждет завершение задачи в UI потоке.</li>
<li><code>Task.Delay()</code> ожидает выполнить продолжение на UI потоке.</li>
<li>Но поток в ожидание - Дедлок!</li>
<li>Все потому, что задача не вернется из <code>DeadlockTestAsync()</code>, пока не выполнится &ldquo;продолжение&rdquo;.</li>
</ol>

<p>Для избежания подобной ситуации, в библиотеках, лучше писать <code>.ConfigureAwait(false)</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1500</span><span class="p">).</span><span class="n">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span></code></pre></div>
<p>Это позволит выполнить &ldquo;продолжение&rdquo; в том же потоке, в котором работала задача. В моем примере это будет поток, отличный от UI потока.</p>

<h3 id="полезные-ссылки">Полезные ссылки</h3>

<ul>
<li>Stephen blog - <a href="http://blog.stephencleary.com/2012/02/async-and-await.html">Async and Await</a></li>
<li>Async/Await - <a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx">Best Practices in Asynchronous Programming</a></li>
<li>Async/Await <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/04/12/10293335.aspx">FAQ</a></li>
<li><a href="http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115642.aspx">Await anything</a></li>
</ul>

    </div>

    <footer class="article-footer__wrapper">
      <div class="article-footer__meta">
  <span title="13 декабря 2016, 17:10 &#43;0300">2016</span>
    <div class="article-footer__meta-tags">
        <a class="article-footer__meta-tag" href="tags/dotnet">dotnet</a>
      </div>
  </div>

    </footer>
  </article>

  <article class="article-layout">
    <header class="article-head__wrapper">
      <div class="article-head">
        <a class="article-head__link" href="https://agladky.ru/blog/drag-and-drop-in-watch-windows/">Перетаскивание кода в окно Watch в Visual Studio</a>
      </div>
    </header>

    <div class="article-content markdown--blackfriday">
      <p>Маленькая хитрость, которую я открыл совсем недавно. Для добавления переменной в окно Watch, необязательно вводить туда значение или копировать и вставлять из редактора. Просто перетащите её:</p>




    


<figure>
	<img src="https://agladky.ru/blog/drag-and-drop-in-watch-windows/images/CopyWatch.gif" alt="Перетаскивание переменной в окно watch">
	<figcaption style="font-size: 0.8rem"></figcaption>
</figure>


<p>Второе окно Watch 2 обрело для меня смысл и, главное, легкость в использовании:</p>




    


<figure>
	<img src="https://agladky.ru/blog/drag-and-drop-in-watch-windows/images/CopyWatch2w.gif" alt="Перетаскивание переменной в окно watch 2">
	<figcaption style="font-size: 0.8rem"></figcaption>
</figure>


<p>Сайт с полезными советами для .Net разработчиков — <a href="http://dailydotnettips.com/">dailydotnettips.com</a>.</p>

    </div>

    <footer class="article-footer__wrapper">
      <div class="article-footer__meta">
  <span title="25 февраля 2016, 13:10 &#43;0300">2016</span>
    <div class="article-footer__meta-tags">
        <a class="article-footer__meta-tag" href="tags/dotnet">dotnet</a>
      
        <a class="article-footer__meta-tag" href="tags/ide">ide</a>
      </div>
  </div>

    </footer>
  </article>

  <article class="article-layout">
    <header class="article-head__wrapper">
      <div class="article-head">
        <a class="article-head__link" href="https://agladky.ru/blog/new-if-null-operator-csharp-6/">Новый оператор ?. в C# 6</a>
      </div>
    </header>

    <div class="article-content markdown--blackfriday">
      

<p>Одно из нововведений в С# 6 — оператор <code>?.</code>. Давайте рассмотрим, где и как его использовать.</p>

<h3 id="преобразование-цепочки-вызовов">Преобразование цепочки вызовов</h3>

<p>С новым оператором уменьшается количество проверок на <code>null</code> в цепочке вызовов:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">documentName</span> <span class="p">=</span> <span class="n">taskManager</span><span class="p">.</span><span class="n">CurrentTask</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span>
  <span class="p">(</span><span class="n">taskManager</span><span class="p">.</span><span class="n">CurrentTask</span><span class="p">.</span><span class="n">GetDocument</span><span class="p">()</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span>
    <span class="n">taskManager</span><span class="p">.</span><span class="n">CurrentTask</span><span class="p">.</span><span class="n">GetDocument</span><span class="p">().</span><span class="n">Name</span><span class="p">);</span></code></pre></div>
<p>Перепишем в одну строчку используя <code>?.</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">documentName</span> <span class="p">=</span> <span class="n">taskManager</span><span class="p">.</span><span class="n">CurrentTask</span><span class="p">?.</span><span class="n">GetDocument</span><span class="p">()?.</span><span class="n">Name</span><span class="p">;</span></code></pre></div>
<p><code>documentName</code> примет значение <code>null</code>, если <code>CurrentTask</code>, <code>GetDocument()</code> или <code>Name</code> вернет <code>null</code>.</p>

<p>Второй вариант компактнее. Также, в первом блоке кода метод <code>GetDocument()</code> вызывается два раза, а во втором — один. Для реализации подобного поведения без использования <code>?.</code> нужна дополнительная переменная для сохранения значения из <code>GetDocument()</code>.</p>

<h3 id="использование-с-индексатором">Использование с индексатором</h3>

<p>Рассмотрим получение значения из коллекции по индексу, с проверкой набора значений на <code>null</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="p">(</span><span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span><span class="na">[index]</span> <span class="p">:</span> <span class="k">null</span><span class="p">;</span></code></pre></div>
<p>С новым оператором проверка на <code>null</code> условным оператором не расписывается. Бонус — выражение в 2 раза короче:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span><span class="p">?</span><span class="na">[index]</span><span class="p">;</span></code></pre></div>
<h3 id="оборачивание-в-нулевые-типы">Оборачивание в нулевые типы</h3>

<p>Результат выполнения <code>String.Equals()</code> — <code>bool</code>. Скомпилируется ли следующий код?</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">String</span> <span class="n">str</span> <span class="p">=</span> <span class="s">&#34;x&#34;</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">result</span> <span class="p">=</span> <span class="n">str</span><span class="p">?.</span><span class="n">Equals</span><span class="p">(</span><span class="s">&#34;x&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Нет. Возникнет ошибка: <code>Cannot implicitly convert type ’bool?’ to ’bool’</code>. Такое поведение ожидаемо, так как <code>str?.Equals(&quot;x&quot;)</code> вернет <code>null</code> если переменная <code>str</code> не инициализирована и <code>bool</code> в остальных случаях.</p>

<p>В подобных ситуациях, при использовании оператора <code>?.</code>, возвращаемый тип функции <code>T</code> будет оборачиваться в <code>Nullable&lt;T&gt;</code>.</p>

<h3 id="использование-в-условии">Использование в условии</h3>

<p>Есть задача — проверить коллекцию на наличие в ней элементов. Типичный код:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span> <span class="p">(</span><span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;Tasks has items!&#34;</span><span class="p">);</span></code></pre></div>
<p>Попробуем переписать:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span> <span class="p">(</span><span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span><span class="p">?.</span><span class="n">Any</span><span class="p">())</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;Tasks has items!&#34;</span><span class="p">);</span></code></pre></div>
<p>Код не скомпилируется. Как написано в предыдущем пункте, <code>taskManager.Tasks?.Any()</code> вернет <code>Nullable&lt;bool&gt;</code> тип, который нельзя однозначно трактовать в условии <code>if</code>. Дополним код:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span> <span class="p">(</span><span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span><span class="p">?.</span><span class="n">Any</span><span class="p">()</span> <span class="p">==</span> <span class="k">true</span><span class="p">)</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;Tasks has items!&#34;</span><span class="p">);</span></code></pre></div>
<p>Работает. И на одно условие стало меньше.</p>

<p>Комбинируя с оператором <code>??</code>, перепишем в эквивалентный код:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span> <span class="p">(</span><span class="n">taskManager</span><span class="p">.</span><span class="n">Tasks</span><span class="p">?.</span><span class="n">Any</span><span class="p">()</span> <span class="p">??</span> <span class="k">false</span><span class="p">)</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&#34;Tasks has items!&#34;</span><span class="p">);</span></code></pre></div>
<h3 id="комбинация-с-оператором">Комбинация с оператором ??</h3>

<p>Оператор <code>??</code> называется оператором объединения со значением <code>null</code>. Если операция возвращает <code>null</code>, оператор <code>??</code> подставит значение из правой части выражения.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">documentName</span> <span class="p">=</span> <span class="n">taskManager</span><span class="p">.</span><span class="n">CurrentTask</span><span class="p">?.</span><span class="n">GetDocument</span><span class="p">()?.</span><span class="n">Name</span> <span class="p">??</span> <span class="s">&#34;No Name&#34;</span><span class="p">;</span></code></pre></div>
<p>Если <code>CurrentTask</code>, <code>GetDocument()</code> или <code>Name</code> вернет <code>null</code>, то переменная примет значение <code>&quot;No Name&quot;</code>.</p>

<h3 id="использование-с-делегатами">Использование с делегатами</h3>

<p>Стандартный код для вызова делегата:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">PropertyChanged</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
  <span class="n">handler</span><span class="p">(</span><span class="err">…</span><span class="p">)</span></code></pre></div>
<p>Используя <code>?.</code>, больше не надо каждый раз писать такой код, делегат вызывается одной строкой:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">PropertyChanged</span><span class="p">?.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code></pre></div>
<p>Компилятор создает код для вычисления PropertyChanged только один раз, запоминая результат во временной переменной.</p>

<p>Обратите внимание, следующий код вызовет ошибку:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">PropertyChanged</span><span class="p">?(</span><span class="n">e</span><span class="p">)</span></code></pre></div>
<p>Вызов метода <code>Invoke</code> обязателен.</p>

<h3 id="полезные-ссылки">Полезные ссылки</h3>

<ul>
<li><a href="https://msdn.microsoft.com/ru-ru/library/ms173224.aspx">Оператор ??</a></li>
<li><a href="https://msdn.microsoft.com/ru-RU/library/dn986595.aspx">Операторы ?. и ?</a></li>
<li><a href="https://msdn.microsoft.com/ru-ru/magazine/dn802602.aspx">Новый и более совершенный C# 6.0</a></li>
</ul>

    </div>

    <footer class="article-footer__wrapper">
      <div class="article-footer__meta">
  <span title="17 февраля 2016, 13:10 &#43;0300">2016</span>
    <div class="article-footer__meta-tags">
        <a class="article-footer__meta-tag" href="tags/dotnet">dotnet</a>
      </div>
  </div>

    </footer>
  </article>

  <article class="article-layout">
    <header class="article-head__wrapper">
      <div class="article-head">
        <a class="article-head__link" href="https://agladky.ru/blog/what-is-a-monad-on-csharp-example/">Что такое монады на примере C#</a>
      </div>
    </header>

    <div class="article-content markdown--blackfriday">
      

<p>Конспект — вольный перевод одного из лучших циклов статей о монадах. Эрик Липперт, на протяжении 13 глав, отвечает на вопрос:</p>

<blockquote>
<p>Я C# разработчик без опыта в «функциональном программировании». Что такое «монада» и как можно её использовать для себя?</p>
</blockquote>

<p>Оригинальный цикл статей доступен по <a href="http://ericlippert.com/category/monads/">тегу monads</a>.</p>

<h3 id="часть-первая">Часть первая</h3>

<p>Монада в функциональном программировании — абстракция линейной цепочки связанных вычислений. Её основное назначение — инкапсуляция функций с побочным эффектом от чистых функций, а точнее, их выполнений от вычислений. (Определение из википедии).</p>

<p>«Шаблон монады» это еще один шаблон для типов. Как, например, одиночка (синглтон).</p>

<h3 id="часть-вторая">Часть вторая</h3>

<ul>
<li><code>Nullable&lt;T&gt;</code> — представляет объект типа T, который может быть <code>null</code> (в дальнейшем, подразумевается что <code>Nullable&lt;T&gt;</code> может работать с любым типом данных).</li>
<li><code>Func&lt;T&gt;</code> — представляет объект типа T, который будет вычислен отложено (в дальнейшем, для большей ясности, будет использоваться делегат <code>delegate T OnDemand&lt;T&gt;();</code>).</li>
<li><code>Lazy&lt;T&gt;</code> — представляет объект типа T, который будет вычислен отложено в первый раз, а после, закеширован.</li>
<li><code>Task&lt;T&gt;</code> — представляет объект типа T, который будет вычислен асинхронно и будет доступен в будущем, если уже не вычислен.</li>
<li><code>IEnumerable&lt;T&gt;</code> — представляет упорядоченную, доступную только для чтения последовательность от нуля и более элементов типа T.</li>
</ul>

<h3 id="часть-третья">Часть третья</h3>

<p>Первое требование для монад: «если <code>M&lt;T&gt;</code> это тип-монада, тогда должен быть простой путь по превращению любого значение типа <code>T</code> в значение типа <code>M&lt;T&gt;</code>». Например:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleNullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleOnDemand</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">item</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleSequence</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">yield</span> <span class="k">return</span> <span class="n">item</span><span class="p">;</span> <span class="p">}</span></code></pre></div>
<p>Кажется, что второе требование просто сформулировать: «из монады <code>M&lt;T&gt;</code>можно получить значение типа <code>T</code>». Но не все так однозначно. Начнем с очень специфичного вопроса. Можно легко прибавить единицу к целочисленному типу, но как «прибавить единицу» к типу-монаде обернутого вокруг целочисленного типа?</p>

<p>Для <code>Nullable&lt;T&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">CreateSimpleNullable</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>  
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre></div>
<p>То есть можно развернуть, произвести операцию и завернуть? Не совсем, если проделать ту же операцию для <code>OnDemand&lt;T&gt;()</code>, который обернут вокруг <code>DateTime.Now.Seconds</code>, то получится статическое значение. Поэтому проделанную операцию вместе с разворачиванием необходимо завернуть в функцию, как показано здесь:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">OnDemand</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">onDemand</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">onDemand</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre></div>
<p>То есть тип монады по требованию, не просто оболочка вокруг значения. Она производит объект, структура которого кодирует последовательность операций, которые будут происходить по требованию. Это одна из особенностей, которая делает монады полезными. Но об этом позже.</p>

<p>Для <code>Lazy&lt;T&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">lazy</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">lazy</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>
<p>Для <code>Task&lt;T&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">async</span> <span class="k">static</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>И, наконец, для <code>IEnumerable&lt;T&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">foreach</span><span class="p">(</span><span class="kt">int</span> <span class="n">unwrapped</span> <span class="k">in</span> <span class="n">sequence</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">unwrapped</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Таким образом, одно из полезных правил для шаблона монад — добавление единицы к завернутому целочисленному типу производит другой завернутый целочисленный тип, с сохранением всех особенностей.</p>

<h3 id="часть-четвертая">Часть четвертая</h3>

<p>Напишем метод, который позволит делать оболочку над любыми <code>Nullable&lt;T&gt;</code> функциями, а не только операцией по добавлению единицы:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
  <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">T</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre></div>
<p>Теперь метод <code>AddOne(...)</code> будет выглядеть так:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">AddOne</span><span class="p">(</span><span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">ApplyFunction</span><span class="p">(</span><span class="n">nullable</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Но, допустим, мы хотим функцию которая принимает тип <code>int</code> и возвращает <code>double</code>. Например, поделить 2 целых числа и получить результат типа <code>double</code>. Для этого, перепишем метод <code>ApplyFunction</code> в следующий вид:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">R</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre></div>
<p>Для остальных типов, можно сделать по аналогии. По сути, получился способ превращения типов из <code>A</code> в <code>R</code> в монадические типы из <code>М&lt;А&gt;</code> в <code>М&lt;R&gt;</code> такие, что сохраняется действие функции и значения, предоставляемые в монадическом («расширенном») типе.</p>

<h3 id="часть-пятая">Часть пятая</h3>

<p>Ранее было указано, что можно взять любую функцию с одним параметром и любым не пустым возвращаемым типом и применить эту функцию к монаде с возвращаемым типом <code>M&lt;R&gt;</code>. Любой возвращаемый тип, так? Предположим, что есть функция с одним параметром:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">SafeLog</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="n">Math</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre></div>
<p>Обычная функция с одним параметром. Значит, ее можно применить к <code>Nullable&lt;int&gt;</code> и получить обратно&hellip; <code>Nullable&lt;Nullable&lt;double&gt;&gt;</code>! Это неправильно.</p>

<p>Создадим новую версию <code>ApplyFunction</code>, которая избегает описанной проблемы:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">nullable</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullable</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">nullable</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre></div>
<p>Просто, не так ли? Создадим функции для остальных операторов:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">onDemand</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">onDemand</span><span class="p">();</span>
    <span class="n">OnDemand</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">();</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">lazy</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">(()</span> <span class="p">=&gt;</span>
  <span class="p">{</span>
    <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="n">lazy</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">Task</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">task</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">A</span> <span class="n">unwrapped</span> <span class="p">=</span> <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
  <span class="n">Task</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">await</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">sequence</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">foreach</span><span class="p">(</span><span class="n">A</span> <span class="n">unwrapped</span> <span class="k">in</span> <span class="n">sequence</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">result</span> <span class="p">=</span> <span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">);</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">R</span> <span class="n">r</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>В итоге для «шаблона монады» имеются 3 правила:</p>

<ol>
<li><p>Всегда существует возможность преобразовать тип <code>T</code> в тип <code>M&lt;T&gt;</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span></code></pre></div></li>

<li><p>Если существует функция, преобразующая <code>A</code> в <code>R</code>, тогда можно применить эту функцию к экземпляру <code>M&lt;A&gt;</code> и получить экземпляр <code>M&lt;R&gt;</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">wrapped</span><span class="p">,</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span></code></pre></div></li>

<li><p>Если существует функция, преобразующая <code>A</code> в <code>M&lt;R&gt;</code>, тогда можно применить эту функцию к экземпляру <code>M&lt;A&gt;</code> и получить экземпляр <code>M&lt;R&gt;</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">wrapped</span><span class="p">,</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span></code></pre></div></li>
</ol>

<p>Но, правило 2 является частным случаем правила 3. Его можно представить в как комбинацию 1 и 3 правила:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplyFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">wrapped</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
    <span class="n">wrapped</span><span class="p">,</span>
    <span class="p">(</span><span class="n">A</span> <span class="n">unwrapped</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">function</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">)));</span>
<span class="p">}</span></code></pre></div>
<p>Остается всего два правила. Они являются полными правилами «шаблона монады»? В принципе, да.</p>

<h3 id="часть-шестая">Часть шестая</h3>

<p>Необходимо, чтобы операции упаковки и распаковки сохраняли значение.</p>

<p>Пусть имеются 2 метода:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
  <span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">monad</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span> <span class="p">{...}</span></code></pre></div>
<p>Тогда, результат следующего выражения:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">someMonadValue</span><span class="p">,</span> <span class="n">CreateSimpleM</span><span class="p">)</span></code></pre></div>
<p>по значению идентичен <code>someMonadValue</code>, а результат следующего выражения:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">CreateSimpleM</span><span class="p">(</span><span class="n">someValue</span><span class="p">),</span> <span class="n">someFunction</span><span class="p">)</span></code></pre></div>
<p>по значению идентичен:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">someFunction</span><span class="p">(</span><span class="n">someValue</span><span class="p">)</span></code></pre></div>
<h3 id="часть-седьмая">Часть седьмая</h3>

<p>Допустим, имеются 2 функции:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;&gt;</span> <span class="n">log</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span>
    <span class="p">?</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="n">Math</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">:</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">&gt;();</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;&gt;</span> <span class="n">toDecimal</span> <span class="p">=</span> <span class="n">y</span> <span class="p">=&gt;</span> <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">&lt;</span> <span class="kt">decimal</span><span class="p">.</span><span class="n">MaxValue</span>
    <span class="p">?</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;((</span><span class="kt">decimal</span><span class="p">)</span><span class="n">y</span><span class="p">)</span>
    <span class="p">:</span> <span class="k">new</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;();</span></code></pre></div>
<p>Тогда, с помощью определенного ранее метода <code>ApplySpecialFunction</code> можно написать следующий метод-помощник:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">ComposeSpecial</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">&gt;(</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">&gt;&gt;</span> <span class="n">f</span><span class="p">,</span>
  <span class="n">Func</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>который позволяет объединить определенные выше функции в одну:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Nullable</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;&gt;</span> <span class="n">both</span> <span class="p">=</span> <span class="n">ComposeSpecial</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">toDecimal</span><span class="p">);</span></code></pre></div>
<p>Отсюда следует последнее правило — метод <code>ApplySpecialFunction</code> должен гарантировать работу композиции. Пример:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">&gt;&gt;</span> <span class="n">f</span> <span class="p">=</span> <span class="n">whatever</span><span class="p">;</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">g</span> <span class="p">=</span> <span class="n">whatever</span><span class="p">;</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">X</span><span class="p">&gt;</span> <span class="n">mx</span> <span class="p">=</span> <span class="n">whatever</span><span class="p">;</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">Y</span><span class="p">&gt;</span> <span class="n">my</span> <span class="p">=</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;</span> <span class="n">mz1</span> <span class="p">=</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">my</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
<span class="n">Func</span><span class="p">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;&gt;</span> <span class="n">h</span> <span class="p">=</span> <span class="n">ComposeSpecial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">Z</span><span class="p">&gt;</span> <span class="n">mz2</span> <span class="p">=</span> <span class="n">ApplySpecialFunction</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span></code></pre></div>
<p>Значения <code>mz1</code> и <code>mz2</code> должны быть одинаковыми.</p>

<p>Наконец, можно полностью описать «шаблон монады» в C#:</p>

<p>Монада — это обобщенный тип <code>M&lt;T&gt;</code>, такой что:</p>

<ul>
<li><p>Для нее существует конструирующий механизм, который принимает на вход переменную типа <code>T</code> и возвращает <code>M&lt;T&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateSimpleM</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span></code></pre></div></li>

<li><p>Если существует способ преобразования значения типа <code>A</code> в <code>M&lt;R&gt;</code>, то можно применить эту функцию к экземпляру <code>M&lt;A&gt;</code> и получить экземпляр <code>M&lt;R&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="n">ApplySpecialFunction</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;(</span>
<span class="n">M</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;</span> <span class="n">monad</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;&gt;</span> <span class="n">function</span><span class="p">)</span></code></pre></div></li>
</ul>

<p>Оба этих метода должны подчиняться следующим законам:</p>

<ul>
<li>Применение функции создающую простую монаду (правило-метод 1) к конкретному экземпляру монады должно приводить к логически идентичному экземпляру монады.</li>
<li>Применение функции к результату функции создающей простую монаду из определенного значения и применение этой функции к определенному значению напрямую должно приводить к логически идентичным экземплярам монад.</li>
<li>Результат применения к значению первой функции второй функции и результат применения первоначального значения к функции-композиции первых двух функций должен приводить к двум логически идентичным экземплярам монад.</li>
</ul>

<h3 id="часть-восьмая">Часть восьмая</h3>

<p>Традиционное имя для функции <code>CreateSimple</code> — <code>unit</code>. В Haskell — <code>return</code>.</p>

<p>Традиционное имя для функции <code>ApplySpecialFunction</code> — <code>bind</code>. В Haskell она является встроенной функцией, для того чтобы применить функцию <code>f</code> на экземпляр монады <code>m</code> необходимо написать <code>m &gt;&gt;= f</code>.</p>

<p>Фактически функция привязки берет неизменный рабочий процесс и операцию над ним и возвращает новый рабочий процесс.</p>

<p>Мой конспект на этом оканчивается. В последующих частях серии рассматривается практическое применение монад в коде.</p>

<ul>
<li><a href="http://ericlippert.com/2013/03/21/monads-part-nine/">Часть 9</a>. О простых монадах «присоединяющих дополнительные данные к значению».</li>
<li><a href="http://ericlippert.com/2013/03/25/monads-part-ten/">Часть 10</a>. О запросах и LINQ на примере <code>SelectMany</code>.</li>
<li><a href="http://ericlippert.com/2013/03/28/monads-part-eleven/">Часть 11</a>. Дополнения к предыдущей главе. Аддитивная монада.</li>
<li><a href="http://ericlippert.com/2013/04/02/monads-part-twelve/">Часть 12</a>. Продолжение про запросы и <code>SelectMany</code>.</li>
<li><a href="http://ericlippert.com/2013/04/03/monads-part-thirteen/">Часть 13</a>. О <code>Task</code> монадах.</li>
</ul>

    </div>

    <footer class="article-footer__wrapper">
      <div class="article-footer__meta">
  <span title="27 января 2016, 13:10 &#43;0300">2016</span>
    <div class="article-footer__meta-tags">
        <a class="article-footer__meta-tag" href="tags/dotnet">dotnet</a>
      
        <a class="article-footer__meta-tag" href="tags/functional">functional</a>
      </div>
  </div>

    </footer>
  </article>

  <article class="article-layout">
    <header class="article-head__wrapper">
      <div class="article-head">
        <a class="article-head__link" href="https://agladky.ru/blog/flags-enums-in-csharp/">C# Enum и Атрибут Flags</a>
      </div>
    </header>

    <div class="article-content markdown--blackfriday">
      

<p>Возникают ситуации, когда переменная должна хранить несколько значений типа перечисления. Например, используемые области логирования: <em>Warning + Info</em>, или сочетания цветов: <em>Red + Blue + Green</em>.</p>

<p>Для хранения в переменной нескольких флагов, значениям енама присваиваются степени двойки:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="na">[Flags]</span>
<span class="k">public</span> <span class="k">enum</span> <span class="n">MyColors</span>
<span class="p">{</span>
    <span class="n">Yellow</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
    <span class="n">Green</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span>
    <span class="n">Red</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span>
    <span class="n">Blue</span> <span class="p">=</span> <span class="m">8</span>
<span class="p">}</span></code></pre></div>
<p>Значения <em>2, 4, 8</em> используются для <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8">операторов смещения</a>, таких как побитовое И (AND), ИЛИ (OR) и исключающее ИЛИ (XOR).</p>

<h3 id="операции-над-переменной">Операции над переменной</h3>

<p>Логическое ИЛИ (<code>|</code>) применяется для помещения нескольких значений флагов в одну переменную:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span> <span class="p">=</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Red</span> <span class="p">|</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span> <span class="p">|</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Blue</span><span class="p">;</span></code></pre></div>
<p>Логическое И (<code>&amp;</code>) помогает при нахождении значения флага:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span><span class="p">((</span><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span> <span class="p">&amp;</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Yellow</span><span class="p">)</span> <span class="p">==</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Yellow</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Yellow has been set...
</span><span class="c1"></span><span class="p">}</span>

<span class="k">if</span><span class="p">((</span><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span> <span class="p">&amp;</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span><span class="p">)</span> <span class="p">==</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Green has been set...
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<p>Начиная с .Net 4 можно использовать сокращенную версию, без явного указания <code>&amp;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">if</span> <span class="p">(</span><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span><span class="p">.</span><span class="n">HasFlag</span><span class="p">(</span><span class="n">MyColor</span><span class="p">.</span><span class="n">Yellow</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// Yellow has been set...
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<p>Операция XOR (’^’) исключает значения из переменной:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span> <span class="p">=</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Red</span> <span class="p">|</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span> <span class="p">|</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Blue</span><span class="p">;</span>
<span class="c1">// Удаляем значение используя оператор смещения XOR.
</span><span class="c1"></span><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span> <span class="p">=</span> <span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span> <span class="p">^</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;My colors are {0}&#34;</span><span class="p">,</span> <span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span><span class="p">);</span>
<span class="p">//</span> <span class="n">Output</span><span class="p">:</span> <span class="n">My</span> <span class="n">colors</span> <span class="n">are</span> <span class="n">Red</span><span class="p">,</span> <span class="n">Blue</span></code></pre></div>
<h3 id="атрибут-flags">Атрибут Flags</h3>

<p>Атрибут <code>[Flags]</code> необязательный и используется для красивого вывода при вызове <code>.ToString()</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">enum</span> <span class="n">Colors</span> <span class="p">{</span> <span class="n">Yellow</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">Green</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span> <span class="n">Red</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span> <span class="n">Blue</span> <span class="p">=</span> <span class="m">8</span> <span class="p">}</span><span class="na">
</span><span class="na">[Flags]</span> <span class="k">enum</span> <span class="n">ColorsFlags</span> <span class="p">{</span> <span class="n">Yellow</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">Green</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span> <span class="n">Red</span> <span class="p">=</span> <span class="m">4</span><span class="p">,</span> <span class="n">Blue</span> <span class="p">=</span> <span class="m">8</span> <span class="p">}</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">str1</span> <span class="p">=</span> <span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">Yellow</span> <span class="p">|</span> <span class="n">Colors</span><span class="p">.</span><span class="n">Red</span><span class="p">).</span><span class="n">ToString</span><span class="p">();</span> <span class="c1">// &#34;5&#34;
</span><span class="c1"></span><span class="kt">var</span> <span class="n">str2</span> <span class="p">=</span> <span class="p">(</span><span class="n">ColorsFlags</span><span class="p">.</span><span class="n">Yellow</span> <span class="p">|</span> <span class="n">ColorsFlags</span><span class="p">.</span><span class="n">Red</span><span class="p">).</span><span class="n">ToString</span><span class="p">();</span> <span class="p">//</span> <span class="s">&#34;Yellow, Red&#34;</span></code></pre></div>
<p>Так же, атрибут <code>[Flags]</code> не присваивает значениям степень двойки. Если не проставить вручную, то значения инициализируются как в обычном енаме.</p>

<p>Неправильное объявление:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="na">[Flags]</span>
<span class="k">public</span> <span class="k">enum</span> <span class="n">MyColors</span>
<span class="p">{</span>
    <span class="n">Yellow</span><span class="p">,</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Blue</span>
<span class="p">}</span></code></pre></div>
<p>Присвоенные значения: <em>Yellow = 0, Green = 1, Red = 2, Blue = 3</em>. Они не подходят для использования операций смещения.</p>

<h3 id="битовое-представление">Битовое представление</h3>

<p>Описанное выше работает благодаря битовому представлению значений флагов при проставлении степени двойки:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">Yellow</span><span class="p">:</span> <span class="m">00000001</span>
<span class="n">Green</span><span class="p">:</span>  <span class="m">00000010</span>
<span class="n">Red</span><span class="p">:</span>    <span class="m">00000100</span>
<span class="n">Blue</span><span class="p">:</span>   <span class="m">00001000</span></code></pre></div>
<p>Значение переменной <code>AllowedColors</code> после присваивания <em>Red, Green</em> и <em>Blue</em> c использованием операции ИЛИ (<code>|</code>):</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span><span class="p">:</span> <span class="m">00001110</span></code></pre></div>
<p>Теперь, для проверки вхождения значения <em>Green</em> в переменную используем операцию смещения И (<code>&amp;</code>):</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">myProperties</span><span class="p">.</span><span class="n">AllowedColors</span><span class="p">:</span> <span class="m">00001110</span>
             <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span><span class="p">:</span> <span class="m">00000010</span>
             <span class="p">-----------------------</span>
                            <span class="m">00000010</span> <span class="p">//</span> <span class="err">Это</span> <span class="err">то</span> <span class="err">же</span> <span class="err">самое</span><span class="p">,</span> <span class="err">что</span> <span class="err">и</span> <span class="n">MyColor</span><span class="p">.</span><span class="n">Green</span><span class="p">!</span></code></pre></div>
<h3 id="полезные-ссылки">Полезные ссылки</h3>

<ul>
<li>What does the [Flags] Enum Attribute mean in csharp? – <a href="http://stackoverflow.com/questions/8447/what-does-the-flags-enum-attribute-mean-in-c">Stackoverflow.com</a></li>
<li>Типы перечислений – <a href="https://msdn.microsoft.com/ru-ru/library/cc138362.aspx">msdn.microsoft.com</a></li>
<li>FlagsAttribute (класс) – <a href="https://msdn.microsoft.com/ru-ru/library/system.flagsattribute(v=vs.110).aspx">msdn.microsoft.com</a></li>
</ul>

    </div>

    <footer class="article-footer__wrapper">
      <div class="article-footer__meta">
  <span title="3 ноября 2015, 13:10 &#43;0300">2015</span>
    <div class="article-footer__meta-tags">
        <a class="article-footer__meta-tag" href="tags/dotnet">dotnet</a>
      </div>
  </div>

    </footer>
  </article>





        </div>
      </main>

      <footer class="footer-layout__container section-skin">
        <div>
          <div>
            <span>© Анатолий Гладкий, 2019</span>
            <a class="footer__rss" href="https://agladky.ru/index.xml">РСС</a>
          </div>
          <span>Эл. почта: <a href="mailto:me@agladky.ru">me@agladky.ru</a></span>
        </div>
      </footer>
    </div>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-75808442-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
  
