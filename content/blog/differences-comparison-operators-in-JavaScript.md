+++
title = "Различия операторов == и === в JavaScript"
date = "2016-02-02T13:10:07+03:00"
tags = ["javascript"]
categories = ["Development"]
draft = true
description = "Когда стоит ипользовать  оператор ==, а когда ===. И почему лучше всегда выбирать опреатор ===."
keywords = "Js, javasript, jshint, ==, ===, различие, сравнение, операторы, рефакторинг"
slug = "differences-comparison-operators-in-JavaScript"
aliases = [
    "/posts/differences-comparison-operators-in-JavaScript/",
    "/2016/02/javascript.html"
]
+++

JsHint, практически во всех случаях, предлагает заменить `==` на `===` и каждый раз я с опаской произвожу данный рефакторинг, можно что-то сломать. Ведь оператор равенства `==` реализует много неявной логики по сравнению значений, чем мог воспользоваться предыдущий разработчик.

Операторы `==` и `===` проверяют два значения на совпадение, используя два разных определения совпадения. Оператор идентичности (identity) `===` проверяет два операнда на «идентичность», руководствуясь строгим определением совпадения. Оператор равенства (equality) `==` проверяет по менее строгим правилам, допускающим преобразования типов.

Оператор идентичности `===` вычисляет значения своих операндов, а затем сравнивает два значения, без преобразования типов, руководствуется следующими правилами:

- Если два значения имеют различные типы, они не идентичны.
- Если оба операнда являются значением `null` или `undefined`, они идентичны.
- Если оба операнда являются логическим значением `true` или оба являются логическим значением `false`, они идентичны.
- Если одно или оба значения являются значением `NaN`, они не идентичны. (Значение `NaN` никогда не бывает идентичным никакому значению, даже самому себе. Чтобы проверить, является ли значение `x` значением `NaN`, следует использовать выражение `x !== x`. Значение NaN – единственное, для которого такая проверка вернет `true`)
- Если оба значения являются числами с одним и тем же значением, они идентичны. Если один операнд имеет значение `0`, а другой `–0`, они также идентичны.
- Если оба значения являются строками и содержат одни и те же 16-битные значения в одинаковых позициях, они идентичны. Две строки могут иметь один и тот же смысл и одинаково выглядеть на экране, но содержать отличающиеся последовательности 16-битных значений. Интерпретатор JavaScript не выполняет нормализацию символов Юникода, поэтому подобные пары строк не считаются операторами `===` и `==` ни равными, ни идентичными.
- Если оба значения ссылаются на один и тот же объект, массив или функцию, то они идентичны. Если они ссылаются на различные объекты (массивы или функции), они не идентичны, даже если оба объекта имеют идентичные свойства.

Оператор равенства `==` похож на оператор идентичности, но он использует менее строгие правила. Если значения операндов имеют разные типы, он выполняет преобразование типов и пытается выполнить сравнение:

- Если два значения имеют одинаковый тип, они проверяются на идентичность, как было описано выше.
- Если два значения не относятся к одному и тому же типу, оператор `==` все же может счесть их равными. При этом используются следующие правила и преобразования типов:
  - Если одно значение `null`, а другое – `undefined`, то они равны.
  - Если одно значение является числом, а другое – строкой, то строка преобразуется в число и выполняется сравнение с преобразованным значением.
  - Если какое-либо значение равно `true`, оно преобразуется в `1` и сравнение выполняется снова. Если какое-либо значение равно `false`, оно преобразуется в `0` и сравнение выполняется снова.
  - Если одно из значений является объектом, а другое – числом или строкой, объект преобразуется в простой тип и сравнение выполняется снова. Объект преобразуется в значение простого типа либо с помощью своего метода `toString()`, либо с помощью своего метода `valueOf()`. Встроенные классы базового языка JavaScript сначала пытаются выполнить преобразование `valueOf()`, а затем `toString()`, кроме класса `Date`, который всегда выполняет преобразование `toString()`. Объекты, не являющиеся частью базового JavaScript, могут преобразовывать себя в значения простых типов способом, определенным их реализацией.
  - Любые другие комбинации значений не являются равными.

Правила, по которым происходит преобразование типов и сравнения значений, для оператора равенства `==`, являются сложными и труднозапоминаемыми. Рассмотрим интересные случаи:
``` js
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

Особый случай, это сравнение литерал с объектом, который определяет тот же литерал, с помощью методов `valueOf()` или `toString()`. Например:
``` js
"abc" == new String("abc")    // true
"abc" === new String("abc")   // false
```

Здесь, оператор `==` проверяет значение двух объектов и возвращает `true`. Оператор `===` возвращает `false`, т.к. объекты имеют различные типы. Какое поведение корректно? Это зависит от того, что надо сравнить. Но лучше полностью обойти вопрос, и просто не использовать конструктор для создания строковых объектов.

В заключении, хочу показать скриншоты таблиц сравнения значений для операторов равенства и идентичности, взятых с сайта [dorey.github.io](http://dorey.github.io/JavaScript-Equality-Table/).

Для оператора `==` (или `!=`):

![](https://lh3.googleusercontent.com/-RCcoFw_NFT4/VrAxefBPSiI/AAAAAAAAAlk/-Ml2va5hHdg/s640-Ic42/Screenshot%2525202016-02-02%25252007.23.08.png)

Для оператора `===` (или `!==`):

![](https://lh3.googleusercontent.com/-37_7dZNdH8g/VrAxeSUggfI/AAAAAAAAAlo/-dgAJViJLnQ/s640-Ic42/Screenshot%2525202016-02-02%25252007.23.34.png)

Из данных таблиц можно сделать вывод, что лучше никогда не использовать оператор равенства `==`. Зачастую, его поведение не совсем очевидно и может только запутать. Используя оператор идентичности `===` всегда можно быть уверенным в возвращаемом значении.

Интересная статья. [When is it OK to use == in JavaScript?](http://www.2ality.com/2011/12/strict-equality-exemptions.html)
